function t(){return{}.toString.call({[Symbol.toStringTag]:"EventEmitterTarget"})}function e(t){if("string"!=typeof t&&"symbol"!=typeof t)throw new TypeError(" EVENTNAME expected: string | symbol;but invalid :"+t)}function n(t){if("function"!=typeof t)throw new TypeError(" EVENTLISTENER expected: (event?: any) => void;but invalid:"+t)}function r(){const r=new Map,o=new WeakMap;function i(t){let e=r.get(t);return e||(e=new Set,r.set(t,e)),e}function u(t){e(t),r.has(t)&&i(t).clear()}function c(t,n){e(t),r.has(t)&&i(t).forEach(t=>{Promise.resolve().then(()=>{t(n)})})}function s(t,r){e(t),n(r),i(t).add(r)}function f(t,e){i(t).delete(e)}function l(t,r){e(t),n(r),f(t,r),function(t,e){const n=i(t);let r=o.get(e);r&&n.delete(r)}(t,r)}function a(){return[...r].map(([t,e])=>[t,[...e]])[Symbol.iterator]()}return{[Symbol.toPrimitive]:t,[Symbol.toStringTag]:"EventEmitterTarget",[Symbol.iterator]:a,entries:a,listenerCount:function(t){return e(t),r.has(t)?i(t).size:0},clear:u,removeAllListeners:u,on:s,addListener:s,off:l,removeListener:l,once:function(t,r){e(t),n(r);let i=!1,u=o.get(r);if(!u){const e=n=>{f(t,e),f(t,r),i||(i=!0,r(n))};u=e,o.set(r,u)}f(t,r),s(t,u)},emit:c,dispatch:c,eventNames:function(){return[...r.keys()]},listeners:function(t){return e(t),r.has(t)?[...i(t)]:[]}}}const o=(t=>{var e=Symbol(),n=new Function("return async()=>{}")()();function o(){const t=r();return this&&this instanceof o?(Object.assign(this,t),this):Reflect.construct(o,[])}return Reflect.set(o,e,n),o})();function i(t){if(!("number"==typeof t&&t>0&&1/0>t))throw TypeError(" MAX expected: number;but invalid:"+t);const e=t,n=new Map;let r=0,i=0;const u=o(),c=[];let s=!0;function f(){const t=r;if(!s)return;if(t>=c.length)return void(s=!1);if("full"===l())return void(s=!1);!function(){if(!(i<e))throw Error();i++,m()}();const o=c[t];if(!o)throw Error();const[u,a]=o,h=Promise.resolve(Reflect.apply(u,void 0,a)),g=()=>{const e=n.get(t);if(!e)throw new Error;e.resolve(h),function(){if(i-1<0)throw Error();i--,m()}(),c[t]=void 0};h.then(g,g),r++,Promise.resolve().then(()=>{f()})}function l(){return i<e?"free":"full"}u.on("free",()=>{s=!0,f()}),u.on("full",()=>{s=!1});const a={[Symbol.toStringTag]:"AsyncCurrentLimiter",asyncwrap:function(t){return async function(...e){return await function(t){let e=c.length;c.push(t),"free"===l()&&(s=!0,f());const r=function(){let t=t=>{},e=t=>{};return{promise:new Promise((n,r)=>{t=n,e=r}),reject:e,resolve:t}}();return n.set(e,r),Promise.resolve(r.promise)}([t,e])}},status:l,limiter:{get max(){return e},get current(){return i}},queue:{get max(){return c.length},get current(){return r}},target:u};function m(){const{queue:t,limiter:n}=a,r={status:l(),queue:{max:t.max,current:t.current},limiter:{max:n.max,current:n.current}};i>=e?u.emit("full",r):u.emit("free",r)}return a}var u=(()=>{var t=new Function("return async()=>{}")()(),e=Symbol();function n(t){const e=i(t);return this&&this instanceof n?(Object.assign(this,e),this):Reflect.construct(n,[t])}return Reflect.set(n,e,t),n})();export default u;
//# sourceMappingURL=index.min.js.map
