{"version":3,"file":"index.js","sources":["../node_modules/@masx200/event-emitter-target/dist/index.js","../src/createlimiter.ts","../src/promisedefer.ts","../src/index.ts"],"sourcesContent":["function t(){return{}.toString.call({[Symbol.toStringTag]:\"EventEmitterTarget\"})}function e(t){if(\"string\"!=typeof t&&\"symbol\"!=typeof t)throw new TypeError(\" EVENTNAME expected: string | symbol;but invalid :\"+t)}function n(t){if(\"function\"!=typeof t)throw new TypeError(\" EVENTLISTENER expected: (event?: any) => void;but invalid:\"+t)}function o(){const o=new Map,r=new WeakMap;function i(t){let e=o.get(t);return e||(e=new Set,o.set(t,e)),e}function c(t){e(t),o.has(t)&&i(t).clear()}function s(t,n){e(t),o.has(t)&&i(t).forEach(t=>{Promise.resolve().then(()=>{t(n)})})}function u(t,o){e(t),n(o),i(t).add(o)}function f(t,e){i(t).delete(e)}function a(t,o){e(t),n(o),f(t,o),function(t,e){const n=i(t);let o=r.get(e);o&&n.delete(o)}(t,o)}function l(){return[...o].map(([t,e])=>[t,[...e]])[Symbol.iterator]()}return{[Symbol.toPrimitive]:t,[Symbol.toStringTag]:\"EventEmitterTarget\",[Symbol.iterator]:l,entries:l,listenerCount:function(t){return e(t),o.has(t)?i(t).size:0},clear:c,removeAllListeners:c,on:u,addListener:u,off:a,removeListener:a,once:function(t,o){e(t),n(o);let i=!1,c=r.get(o);if(!c){const e=n=>{f(t,e),f(t,o),i||(i=!0,o(n))};c=e,r.set(o,c)}f(t,o),u(t,c)},emit:s,dispatch:s,eventNames:function(){return[...o.keys()]},listeners:function(t){return e(t),o.has(t)?[...i(t)]:[]}}}const r=(t=>{var e=Symbol(),n=new Function(\"return async()=>{}\")()();function r(){const t=o();return this&&this instanceof r?(Object.assign(this,t),this):Reflect.construct(r,[])}return Reflect.set(r,e,n),r})();export default r;\n//# sourceMappingURL=index.js.map\n","type FUNRETPRO<T> = (...arg: any[]) => Promise<T>;\n\nexport type 空闲状态 = \"free\" | \"full\";\n\ninterface FUNANDARGS<T, S extends FUNRETPRO<T>> extends Array<any> {\n    0: S;\n    1: Parameters<S>;\n    length: 2;\n}\nimport createeventtarget, {\n    EventEmitterTarget,\n} from \"@masx200/event-emitter-target\";\nimport promisedefer from \"./promisedefer\";\nimport { AsyncCurrentLimiter } from \"./AsyncCurrentLimiter\";\n// import { FUNANDARGS, FUNRETPRO, 空闲状态 } from './index';\nexport function createlimiter(max: number): AsyncCurrentLimiter {\n    if (!(typeof max === \"number\" && max > 0 && Infinity > max)) {\n        throw TypeError(\" MAX expected: number;but invalid:\" + max);\n    }\n    const 同时读取的最大文件数 = max;\n    const cachepromise = new Map<number, ReturnType<typeof promisedefer>>();\n    // const cachesymbol = new Map<string, symbol>();\n    // const getsymbolcached = (name: string) => {\n    //     const cached = cachesymbol.get(name);\n    //     if (cached) {\n    //         return cached;\n    //     }\n    //     else {\n    //         const s = Symbol(name);\n    //         cachesymbol.set(name, s);\n    //         return s;\n    //     }\n    // };\n    let pointer = 0;\n    let 当前同时读取的文件数 = 0;\n    const target: EventEmitterTarget = createeventtarget();\n    const queue: (undefined | FUNANDARGS<any, any>)[] = [];\n    let shouldrun = true;\n    target.on(\"free\", () => {\n        shouldrun = true;\n        next();\n    });\n    target.on(\"full\", () => {\n        shouldrun = false;\n    });\n    function next() {\n        const index = pointer;\n        if (!shouldrun) {\n            return;\n        }\n        if (index >= queue.length) {\n            shouldrun = false;\n            return;\n        }\n        if (status() === \"full\") {\n            shouldrun = false;\n            return;\n        }\n        incre();\n        const funargs = queue[index];\n        if (!funargs) {\n            throw Error();\n        }\n        const [fun, args] = funargs;\n        const promise = Promise.resolve(Reflect.apply(fun, undefined, args));\n        const settle = () => {\n            // target.emit(getsymbolcached(\"settle\" + index), promise);\n            const defer = cachepromise.get(index);\n            if (defer) {\n                defer.resolve(promise);\n            } else {\n                throw new Error();\n            }\n            decre();\n            /* 内存垃圾回收 */\n            queue[index] = undefined;\n            cachepromise.delete(index);\n        };\n        promise.then(settle, settle);\n        pointer++;\n        Promise.resolve().then(() => {\n            next();\n        });\n    }\n    function add<T, S extends FUNRETPRO<T>>(\n        funargs: FUNANDARGS<T, S>\n    ): Promise<T> {\n        let index = queue.length;\n        queue.push(funargs);\n        if (status() === \"free\") {\n            shouldrun = true;\n            next();\n        }\n        const defer = promisedefer();\n        cachepromise.set(index, defer);\n        return Promise.resolve(defer.promise) as Promise<T>;\n        /*  return new Promise<T>(res => {\n            target.once(\n                getsymbolcached(\"settle\" + index),\n                (settledpromise: Promise<T>) => {\n                    res(settledpromise);\n                }\n            );\n        }); */\n    }\n    function status(): 空闲状态 {\n        return 当前同时读取的文件数 < 同时读取的最大文件数 ? \"free\" : \"full\";\n    }\n    const asyncwrap = function <T extends (...args: any[]) => Promise<any>>(\n        fun: T\n    ): T {\n        return async function (...args: Parameters<T>) {\n            return await add([fun, args]);\n        } as T;\n    };\n    const 文件读取队列 = {\n        [Symbol.toStringTag]: \"AsyncCurrentLimiter\",\n        // add,\n        asyncwrap,\n        status,\n        limiter: {\n            get max() {\n                return 同时读取的最大文件数;\n            },\n            get current() {\n                return 当前同时读取的文件数;\n            },\n        },\n        queue: {\n            get max() {\n                return queue.length;\n            },\n            get current() {\n                return pointer;\n            },\n        },\n        target,\n    };\n    function decre() {\n        if (当前同时读取的文件数 - 1 < 0) {\n            throw Error();\n        }\n        当前同时读取的文件数--;\n        dispatchstatus();\n    }\n    function dispatchstatus() {\n        const { queue, limiter } = 文件读取队列;\n        const data = {\n            status: status(),\n            queue: { max: queue.max, current: queue.current },\n            limiter: { max: limiter.max, current: limiter.current },\n        };\n        if (当前同时读取的文件数 >= 同时读取的最大文件数) {\n            target.emit(\"full\", data);\n        } else {\n            target.emit(\"free\", data);\n        }\n    }\n    function incre() {\n        if (当前同时读取的文件数 < 同时读取的最大文件数) {\n            当前同时读取的文件数++;\n            dispatchstatus();\n        } else {\n            throw Error();\n        }\n    }\n    return 文件读取队列;\n}\n","export default function promisedefer() {\n    let resolve: (value?: any) => void = (value?: any) => void 0;\n    let reject: (reason?: any) => void = (reason?: any) => void 0;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, reject, resolve };\n}\n","import { EventEmitterTarget } from \"@masx200/event-emitter-target\";\nimport { AsyncCurrentLimiter } from \"./AsyncCurrentLimiter\";\nimport { createlimiter } from \"./createlimiter\";\nimport { statusdata } from \"./status-event\";\n\ninterface Constructor<T extends (...args: any[]) => any> {\n    new (...args: Parameters<T>): ReturnType<T>;\n    (...args: Parameters<T>): ReturnType<T>;\n}\nexport type AsyncLimiterConstructor = Constructor<typeof createlimiter>;\nexport { AsyncCurrentLimiter };\nexport { statusdata };\nexport default (() => {\n    /* 检测是否支持async函数 */\n    var b = new Function(\"return async()=>{}\")()();\n    var a = Symbol();\n    function AsyncLimiterClass(this: any, max: number) {\n        const asynclimiter = createlimiter(max);\n        if (this && this instanceof AsyncLimiterClass) {\n            Object.assign(this, asynclimiter);\n            return this as EventEmitterTarget;\n        } else {\n            return Reflect.construct(AsyncLimiterClass, [max]);\n        }\n    }\n    Reflect.set(AsyncLimiterClass, a, b);\n    return AsyncLimiterClass as AsyncLimiterConstructor;\n})();\n"],"names":["t","toString","call","[object Object]","Symbol","toStringTag","e","TypeError","n","o","Map","r","WeakMap","i","get","Set","set","c","has","clear","s","forEach","Promise","resolve","then","u","add","f","delete","a","l","map","iterator","toPrimitive","entries","listenerCount","size","removeAllListeners","on","addListener","off","removeListener","once","emit","dispatch","eventNames","keys","listeners","Function","this","Object","assign","Reflect","construct","createlimiter","max","Infinity","同时读取的最大文件数","cachepromise","pointer","当前同时读取的文件数","target","createeventtarget","queue","shouldrun","next","index","length","status","Error","dispatchstatus","incre","funargs","fun","args","promise","apply","undefined","settle","defer","decre","push","value","reject","reason","res","rej","promisedefer","文件读取队列","asyncwrap","async","limiter","current","data","b","AsyncLimiterClass","asynclimiter"],"mappings":"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"}