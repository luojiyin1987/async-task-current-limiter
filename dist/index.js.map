{"version":3,"file":"index.js","sources":["../src/createlimiter.ts","../src/promisedefer.ts","../src/index.ts"],"sourcesContent":["type FUNRETPRO<T> = (...arg: any[]) => Promise<T>;\n\nexport type 空闲状态 = \"free\" | \"full\";\n\ninterface FUNANDARGS<T, S extends FUNRETPRO<T>> extends Array<any> {\n    0: S;\n    1: Parameters<S>;\n    length: 2;\n}\nimport createeventtarget, {\n    EventEmitterTarget,\n} from \"@masx200/event-emitter-target\";\nimport promisedefer from \"./promisedefer\";\nimport { AsyncCurrentLimiter } from \"./AsyncCurrentLimiter\";\n// import { FUNANDARGS, FUNRETPRO, 空闲状态 } from './index';\nexport function createlimiter(max: number): AsyncCurrentLimiter {\n    if (!(typeof max === \"number\" && max > 0 && Infinity > max)) {\n        throw TypeError(\" MAX expected: number;but invalid:\" + max);\n    }\n    const 同时读取的最大文件数 = max;\n    const cachepromise = new Map<number, ReturnType<typeof promisedefer>>();\n    // const cachesymbol = new Map<string, symbol>();\n    // const getsymbolcached = (name: string) => {\n    //     const cached = cachesymbol.get(name);\n    //     if (cached) {\n    //         return cached;\n    //     }\n    //     else {\n    //         const s = Symbol(name);\n    //         cachesymbol.set(name, s);\n    //         return s;\n    //     }\n    // };\n    let pointer = 0;\n    let 当前同时读取的文件数 = 0;\n    const target: EventEmitterTarget = createeventtarget();\n    const queue: (undefined | FUNANDARGS<any, any>)[] = [];\n    let shouldrun = true;\n    target.on(\"free\", () => {\n        shouldrun = true;\n        next();\n    });\n    target.on(\"full\", () => {\n        shouldrun = false;\n    });\n    function next() {\n        const index = pointer;\n        if (!shouldrun) {\n            return;\n        }\n        if (index >= queue.length) {\n            shouldrun = false;\n            return;\n        }\n        if (status() === \"full\") {\n            shouldrun = false;\n            return;\n        }\n        incre();\n        const funargs = queue[index];\n        if (!funargs) {\n            throw Error();\n        }\n        const [fun, args] = funargs;\n        const promise = Promise.resolve(Reflect.apply(fun, undefined, args));\n        const settle = () => {\n            // target.emit(getsymbolcached(\"settle\" + index), promise);\n            const defer = cachepromise.get(index);\n            if (defer) {\n                defer.resolve(promise);\n            } else {\n                throw new Error();\n            }\n            decre();\n            /* 内存垃圾回收 */\n            queue[index] = undefined;\n            cachepromise.delete(index);\n        };\n        promise.then(settle, settle);\n        pointer++;\n        Promise.resolve().then(() => {\n            next();\n        });\n    }\n    function add<T, S extends FUNRETPRO<T>>(\n        funargs: FUNANDARGS<T, S>\n    ): Promise<T> {\n        let index = queue.length;\n        queue.push(funargs);\n        if (status() === \"free\") {\n            shouldrun = true;\n            next();\n        }\n        const defer = promisedefer();\n        cachepromise.set(index, defer);\n        return Promise.resolve(defer.promise) as Promise<T>;\n        /*  return new Promise<T>(res => {\n            target.once(\n                getsymbolcached(\"settle\" + index),\n                (settledpromise: Promise<T>) => {\n                    res(settledpromise);\n                }\n            );\n        }); */\n    }\n    function status(): 空闲状态 {\n        return 当前同时读取的文件数 < 同时读取的最大文件数 ? \"free\" : \"full\";\n    }\n    const asyncwrap = function <T extends (...args: any[]) => Promise<any>>(\n        fun: T\n    ): T {\n        return async function (...args: Parameters<T>) {\n            return await add([fun, args]);\n        } as T;\n    };\n    const 文件读取队列 = {\n        [Symbol.toStringTag]: \"AsyncCurrentLimiter\",\n        // add,\n        asyncwrap,\n        status,\n        limiter: {\n            get max() {\n                return 同时读取的最大文件数;\n            },\n            get current() {\n                return 当前同时读取的文件数;\n            },\n        },\n        queue: {\n            get max() {\n                return queue.length;\n            },\n            get current() {\n                return pointer;\n            },\n        },\n        target,\n    };\n    function decre() {\n        if (当前同时读取的文件数 - 1 < 0) {\n            throw Error();\n        }\n        当前同时读取的文件数--;\n        dispatchstatus();\n    }\n    function dispatchstatus() {\n        const { queue, limiter } = 文件读取队列;\n        const data = {\n            status: status(),\n            queue: { max: queue.max, current: queue.current },\n            limiter: { max: limiter.max, current: limiter.current },\n        };\n        if (当前同时读取的文件数 >= 同时读取的最大文件数) {\n            target.emit(\"full\", data);\n        } else {\n            target.emit(\"free\", data);\n        }\n    }\n    function incre() {\n        if (当前同时读取的文件数 < 同时读取的最大文件数) {\n            当前同时读取的文件数++;\n            dispatchstatus();\n        } else {\n            throw Error();\n        }\n    }\n    return 文件读取队列;\n}\n","export default function promisedefer() {\n    let resolve: (value?: any) => void = (value?: any) => void 0;\n    let reject: (reason?: any) => void = (reason?: any) => void 0;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, reject, resolve };\n}\n","import { EventEmitterTarget } from \"@masx200/event-emitter-target\";\nimport { AsyncCurrentLimiter } from \"./AsyncCurrentLimiter\";\nimport { createlimiter } from \"./createlimiter\";\nimport { statusdata } from \"./status-event\";\n\ninterface Constructor<T extends (...args: any[]) => any> {\n    new (...args: Parameters<T>): ReturnType<T>;\n    (...args: Parameters<T>): ReturnType<T>;\n}\nexport type AsyncLimiterConstructor = Constructor<typeof createlimiter>;\nexport { AsyncCurrentLimiter };\nexport { statusdata };\nexport default (() => {\n    /* 检测是否支持async函数 */\n    var b = new Function(\"return async()=>{}\")()();\n    var a = Symbol();\n    function AsyncLimiterClass(this: any, max: number) {\n        const asynclimiter = createlimiter(max);\n        if (this && this instanceof AsyncLimiterClass) {\n            Object.assign(this, asynclimiter);\n            return this as EventEmitterTarget;\n        } else {\n            return Reflect.construct(AsyncLimiterClass, [max]);\n        }\n    }\n    Reflect.set(AsyncLimiterClass, a, b);\n    return AsyncLimiterClass as AsyncLimiterConstructor;\n})();\n"],"names":["createlimiter","max","Infinity","TypeError","cachepromise","Map","pointer","target","createeventtarget","queue","shouldrun","next","index","length","status","Error","dispatchstatus","incre","funargs","fun","args","promise","Promise","resolve","Reflect","apply","undefined","settle","defer","get","decre","delete","then","add","push","value","reject","reason","res","rej","promisedefer","set","on","Symbol","toStringTag","asyncwrap","async","limiter","current","data","emit","b","Function","a","AsyncLimiterClass","asynclimiter","this","Object","assign","construct"],"mappings":"6CAeM,SAAUA,EAAcC,GAC1B,KAAqB,iBAARA,GAAoBA,EAAM,GAAKC,EAAAA,EAAWD,GACnD,MAAME,UAAU,qCAAuCF,GAE3D,MAAM,EAAaA,EACbG,EAAe,IAAIC,IAazB,IAAIC,EAAU,EACV,EAAa,EACjB,MAAMC,EAA6BC,IAC7BC,EAA8C,GACpD,IAAIC,GAAY,EAQhB,SAASC,IACL,MAAMC,EAAQN,EACd,IAAKI,EACD,OAEJ,GAAIE,GAASH,EAAMI,OAEf,YADAH,GAAY,GAGhB,GAAiB,SAAbI,IAEA,YADAJ,GAAY,IAuGpB,WACI,KAAI,EAAa,GAIb,MAAMK,QAHN,IACAC,IAvGJC,GACA,MAAMC,EAAUT,EAAMG,GACtB,IAAKM,EACD,MAAMH,QAEV,MAAOI,EAAKC,GAAQF,EACdG,EAAUC,QAAQC,QAAQC,QAAQC,MAAMN,OAAKO,EAAWN,IACxDO,EAAS,KAEX,MAAMC,EAAQxB,EAAayB,IAAIjB,GAC/B,IAAIgB,EAGA,MAAM,IAAIb,MAFVa,EAAML,QAAQF,GAqE1B,WACI,GAAI,EAAa,EAAI,EACjB,MAAMN,QAEV,IACAC,IAtEIc,GAEArB,EAAMG,QAASc,EACftB,EAAa2B,OAAOnB,IAExBS,EAAQW,KAAKL,EAAQA,GACrBrB,IACAgB,QAAQC,UAAUS,MAAK,KACnBrB,OAGR,SAASsB,EACLf,GAEA,IAAIN,EAAQH,EAAMI,OAClBJ,EAAMyB,KAAKhB,GACM,SAAbJ,MACAJ,GAAY,EACZC,KAEJ,MAAMiB,EC7FA,WACV,IAAIL,EAAkCY,MAClCC,EAAkCC,MAKtC,MAAO,CAAEhB,QAJO,IAAIC,SAAQ,CAACgB,EAAKC,KAC9BhB,EAAUe,EACVF,EAASG,KAEKH,OAAAA,EAAQb,QAAAA,GDsFRiB,GAEd,OADApC,EAAaqC,IAAI7B,EAAOgB,GACjBN,QAAQC,QAAQK,EAAMP,SAUjC,SAASP,IACL,OAAO,EAAa,EAAa,OAAS,OApE9CP,EAAOmC,GAAG,QAAQ,KACdhC,GAAY,EACZC,OAEJJ,EAAOmC,GAAG,QAAQ,KACdhC,GAAY,KAiEhB,MAOM,EAAS,CACX,CAACiC,OAAOC,aAAc,sBAEtBC,UAVc,SACd1B,GAEA,OAAO2B,kBAAmB1B,GACtB,aAAaa,EAAI,CAACd,EAAKC,MAO3BN,OAAAA,EACAiC,QAAS,CACD9C,UACA,OAAO,GAEP+C,cACA,OAAO,IAGfvC,MAAO,CACCR,UACA,OAAOQ,EAAMI,QAEbmC,cACA,OAAO1C,IAGfC,OAAAA,GASJ,SAASS,IACL,MAAMP,MAAEA,EAAKsC,QAAEA,GAAY,EACrBE,EAAO,CACTnC,OAAQA,IACRL,MAAO,CAAER,IAAKQ,EAAMR,IAAK+C,QAASvC,EAAMuC,SACxCD,QAAS,CAAE9C,IAAK8C,EAAQ9C,IAAK+C,QAASD,EAAQC,UAE9C,GAAc,EACdzC,EAAO2C,KAAK,OAAQD,GAEpB1C,EAAO2C,KAAK,OAAQD,GAW5B,OAAO,EE1JX,IAAArC,EAAe,MAEX,IAAIuC,EAAI,IAAIC,SAAS,qBAAb,EAAA,GACJC,EAAIV,SACR,SAASW,EAA6BrD,GAClC,MAAMsD,EAAevD,EAAcC,GACnC,OAAIuD,MAAQA,gBAAgBF,GACxBG,OAAOC,OAAOF,KAAMD,GACbC,MAEAhC,QAAQmC,UAAUL,EAAmB,CAACrD,IAIrD,OADAuB,QAAQiB,IAAIa,EAAmBD,EAAGF,GAC3BG,GAdI"}