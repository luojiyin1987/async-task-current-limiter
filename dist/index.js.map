{"version":3,"file":"index.js","sources":["../src/promisedefer.ts","../src/createlimiter.ts","../src/index.ts"],"sourcesContent":["export default function promisedefer() {\r\n    let resolve: (value?: any) => void = (value?: any) => void 0;\r\n    let reject: (reason?: any) => void = (reason?: any) => void 0;\r\n    const promise = new Promise((res, rej) => {\r\n        resolve = res;\r\n        reject = rej;\r\n    });\r\n    return { promise, reject, resolve };\r\n}\r\n","type FUNRETPRO<T> = (...arg: any[]) => Promise<T>;\r\n\r\ntype 空闲状态 = \"free\" | \"full\";\r\n\r\ninterface FUNANDARGS<T, S extends FUNRETPRO<T>> extends Array<any> {\r\n    0: S;\r\n    1: Parameters<S>;\r\n    length: 2;\r\n}\r\n\r\nimport createeventtarget, {\r\n    EventEmitterTarget\r\n} from \"@masx200/event-emitter-target\";\r\nimport promisedefer from \"./promisedefer\";\r\n// import { FUNANDARGS, FUNRETPRO, 空闲状态 } from './index';\r\nexport function createlimiter(max: number) {\r\n    if (!(typeof max === \"number\" && max > 0 && Infinity > max)) {\r\n        throw TypeError(\" MAX expected: number;but invalid:\" + max);\r\n    }\r\n    const 同时读取的最大文件数 = max;\r\n    const cachepromise = new Map<number, ReturnType<typeof promisedefer>>();\r\n    // const cachesymbol = new Map<string, symbol>();\r\n    // const getsymbolcached = (name: string) => {\r\n    //     const cached = cachesymbol.get(name);\r\n    //     if (cached) {\r\n    //         return cached;\r\n    //     }\r\n    //     else {\r\n    //         const s = Symbol(name);\r\n    //         cachesymbol.set(name, s);\r\n    //         return s;\r\n    //     }\r\n    // };\r\n    let pointer = 0;\r\n    let 当前同时读取的文件数 = 0;\r\n    const target: EventEmitterTarget = createeventtarget();\r\n    const queue: (undefined | FUNANDARGS<any, any>)[] = [];\r\n    let shouldrun = true;\r\n    target.on(\"free\", () => {\r\n        shouldrun = true;\r\n        next();\r\n    });\r\n    target.on(\"full\", () => {\r\n        shouldrun = false;\r\n    });\r\n    function next() {\r\n        const index = pointer;\r\n        if (!shouldrun) {\r\n            return;\r\n        }\r\n        if (index >= queue.length) {\r\n            shouldrun = false;\r\n            return;\r\n        }\r\n        if (status() === \"full\") {\r\n            shouldrun = false;\r\n            return;\r\n        }\r\n        incre();\r\n        const funargs = queue[index];\r\n        if (!funargs) {\r\n            throw Error();\r\n        }\r\n        const [fun, args] = funargs;\r\n        const promise = Promise.resolve(Reflect.apply(fun, undefined, args));\r\n        const settle = () => {\r\n            // target.emit(getsymbolcached(\"settle\" + index), promise);\r\n            const defer = cachepromise.get(index);\r\n            if (defer) {\r\n                defer.resolve(promise);\r\n            } else {\r\n                throw new Error();\r\n            }\r\n            decre();\r\n            /* 内存垃圾回收 */\r\n            queue[index] = undefined;\r\n        };\r\n        promise.then(settle, settle);\r\n        pointer++;\r\n        Promise.resolve().then(() => {\r\n            next();\r\n        });\r\n    }\r\n    function add<T, S extends FUNRETPRO<T>>(\r\n        funargs: FUNANDARGS<T, S>\r\n    ): Promise<T> {\r\n        let index = queue.length;\r\n        queue.push(funargs);\r\n        if (status() === \"free\") {\r\n            shouldrun = true;\r\n            next();\r\n        }\r\n        const defer = promisedefer();\r\n        cachepromise.set(index, defer);\r\n        return Promise.resolve(defer.promise) as Promise<T>;\r\n        /*  return new Promise<T>(res => {\r\n            target.once(\r\n                getsymbolcached(\"settle\" + index),\r\n                (settledpromise: Promise<T>) => {\r\n                    res(settledpromise);\r\n                }\r\n            );\r\n        }); */\r\n    }\r\n    function status(): 空闲状态 {\r\n        return 当前同时读取的文件数 < 同时读取的最大文件数 ? \"free\" : \"full\";\r\n    }\r\n    const asyncwrap = function<T extends (...args: any[]) => Promise<any>>(\r\n        fun: T\r\n    ): T {\r\n        return async function(...args: Parameters<T>) {\r\n            return await add([fun, args]);\r\n        } as T;\r\n    };\r\n    const 文件读取队列 = {\r\n        // add,\r\n        asyncwrap,\r\n        status,\r\n        limiter: {\r\n            get max() {\r\n                return 同时读取的最大文件数;\r\n            },\r\n            get current() {\r\n                return 当前同时读取的文件数;\r\n            }\r\n        },\r\n        queue: {\r\n            get max() {\r\n                return queue.length;\r\n            },\r\n            get current() {\r\n                return pointer;\r\n            }\r\n        },\r\n        target\r\n    };\r\n    function decre() {\r\n        if (当前同时读取的文件数 - 1 < 0) {\r\n            throw Error();\r\n        }\r\n        当前同时读取的文件数--;\r\n        dispatchstatus();\r\n    }\r\n    function dispatchstatus() {\r\n        const { queue, limiter } = 文件读取队列;\r\n        const data = {\r\n            status: status(),\r\n            queue: { max: queue.max, current: queue.current },\r\n            limiter: { max: limiter.max, current: limiter.current }\r\n        };\r\n        if (当前同时读取的文件数 >= 同时读取的最大文件数) {\r\n            target.emit(\"full\", data);\r\n        } else {\r\n            target.emit(\"free\", data);\r\n        }\r\n    }\r\n    function incre() {\r\n        if (当前同时读取的文件数 < 同时读取的最大文件数) {\r\n            当前同时读取的文件数++;\r\n            dispatchstatus();\r\n        } else {\r\n            throw Error();\r\n        }\r\n    }\r\n    return 文件读取队列;\r\n}\r\n","import { EventEmitterTarget } from \"@masx200/event-emitter-target\";\r\nimport { statusdata } from \"./status-event\";\r\nimport { createlimiter } from \"./createlimiter\";\r\n\r\ninterface Constructor<T extends (...args: any[]) => any> {\r\n    new (...args: Parameters<T>): ReturnType<T>;\r\n    (...args: Parameters<T>): ReturnType<T>;\r\n}\r\nexport type AsyncLimiterConstructor = Constructor<typeof createlimiter>;\r\n\r\nexport default (() => {\r\n    /* 检测是否支持async函数 */\r\n    new Function(\"return async()=>{}\")()();\r\n\r\n    function AsyncLimiterClass(this: any, max: number) {\r\n        const asynclimiter = createlimiter(max);\r\n        if (this && this instanceof AsyncLimiterClass) {\r\n            Object.assign(this, asynclimiter);\r\n            return this as EventEmitterTarget;\r\n        } else {\r\n            return asynclimiter;\r\n        }\r\n    }\r\n    return AsyncLimiterClass as AsyncLimiterConstructor;\r\n})();\r\n\r\nexport { statusdata };\r\n"],"names":["createeventtarget"],"mappings":"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"}